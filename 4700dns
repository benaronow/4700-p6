#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A

class Server:
    def __init__(self, root_ip, domain, port):
        self.root_ip = root_ip
        self.domain = domain
        self.log(domain)

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr, message):
        self.log("Sending message:\n%s" % message)
        self.socket.sendto(message.pack(), addr)
        
    def get_local_res(self, response):
        zoneStr = open('configs/example.com.zone', 'r').read()
        
        question = response.get_q()
        qname = question.qname
        qtype = question.qtype
        
        # handles NS question type
        if qtype == 2:
            for rr in RR.fromZone(zoneStr):
                # adds matching answer if NS
                if (rr.rname == qname) & (rr.rtype == 2):
                    response.add_answer(rr)
                    
                    qname2 = rr.rdata.toZone()
                    for rr2 in RR.fromZone(zoneStr):
                        if rr2.rname == qname2:
                            response.add_ar(rr2)
             
            # sets status to NXDOMAIN if no auth
            if response.header.a == 0: response.header.set_rcode(3)
            return response
        
        # handles other question types
        for rr in RR.fromZone(zoneStr):
            # adds matching answer if not SOA or NS
            if (rr.rname == qname) & (rr.rtype != 6) & (rr.rtype != 2):
                response.add_answer(rr)
                
                # adds additional answers if rr is CNAME
                if (rr.rtype == 5):
                    qname2 = rr.rdata.toZone()
                    for rr2 in RR.fromZone(zoneStr):
                        if rr2.rname == qname2:
                            response.add_answer(rr2)
            
            # adds authority section, should probably un-hard-code
            if (rr.rname == 'example.com') & (rr.rtype == 2): response.add_auth(rr)
                            
        # sets status to NXDOMAIN if no answers
        if response.header.a == 0: response.header.set_rcode(3)
        return response
    
    # Sending a query to a DNS server and receiving a response.
    def get_ext_res(self, message):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.bind(("0.0.0.0", 60053))
            sock.settimeout(1000)
            sock.sendto(message, (self.root_ip, 60053))
            data, _ = sock.recvfrom(65535)
            request = DNSRecord.parse(data)
            return request
        except (socket.timeout, socket.error):
            return None

    def recv(self, socket):
        data, addr = socket.recvfrom(65535)

        # Unpack the DNS request
        request = DNSRecord.parse(data)
        self.log("Received message:\n%s" % request)

        response = request.reply()
        local_res = self.get_local_res(response)
        print(local_res.header.rcode)
        if local_res.header.rcode != 3:
            # set authoritative bit
            local_res.header.set_aa(1)
            self.send(addr, local_res)
        else:
            ext_res = self.get_ext_res(data)
            if ext_res.header.rcode != 3:
                # unset authoritative bit
                ext_res.header.set_aa(0)
                # set recursion available bit
                ext_res.header.set_ra(1)
                self.send(addr, ext_res)
            else:
                self.send(addr, local_res)

    def run(self):
        seq = 0
        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)

        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
